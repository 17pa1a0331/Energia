/*
  Example sketch to demonstrate functionality of FFT DSP API library.
  FFT transform is computed for audio received from Audio input port.
  IFFT is computed for FFT output in order to get the audio signal 
  into time domain. The resulting signal is sent to the Audio output.
  
  Procedure:
  1. Connect Arduino to host PC using USB cable.
  2. Verify and Upload the example binary to DSP shield.
  3. Connect linein audio cable from PC to pink Jack on DSP shield.
  4. Connect head phone to green jack of DSP shield.
  5. Open Serial Monitor and connect to the Arduino Uno COM port.
  6. Set the baud rate to 9600.
  7. Observe the messages displayed on the Serial Monitor.
  8. Play sine wave in PC and listen to the audio from head phone.
*/

#include "FFT.h"
#include "Audio.h"

long coeff32[I2S_DMA_BUF_LEN];
long dmaBuffReadL32[I2S_DMA_BUF_LEN];
long dmaBuffReadR32[I2S_DMA_BUF_LEN];

unsigned short fftBuf1[I2S_DMA_BUF_LEN];
unsigned short fftBuf2[I2S_DMA_BUF_LEN];

volatile int readyForFFT;
volatile int fftbufAvailable;
int writeBufIndex;

// Fs = 48KHz, Fc = 2KHz, Hamming window 511 taps
int coeffs[I2S_DMA_BUF_LEN] = {
		0xfffe,	0xfffe,	0xffff,	0x0000,	0x0001,	0x0002,	0x0002,	0x0003,
		0x0003,	0x0004,	0x0003,	0x0003,	0x0003,	0x0002,	0x0001,	0x0000,
		0xffff,	0xfffe,	0xfffd,	0xfffc,	0xfffc,	0xfffc,	0xfffc,	0xfffc,
		0xfffd,	0xfffe,	0xffff,	0x0000,	0x0001,	0x0003,	0x0004,	0x0005,
		0x0005,	0x0006,	0x0005,	0x0005,	0x0004,	0x0003,	0x0002,	0x0000,
		0xfffe,	0xfffd,	0xfffb,	0xfffa,	0xfff9,	0xfff9,	0xfff9,	0xfff9,
		0xfffa,	0xfffc,	0xfffe,	0x0000,	0x0002,	0x0005,	0x0007,	0x0008,
		0x0009,	0x000a,	0x000a,	0x0009,	0x0008,	0x0005,	0x0003,	0x0000,
		0xfffd,	0xfffa,	0xfff7,	0xfff5,	0xfff3,	0xfff3,	0xfff3,	0xfff4,
		0xfff6,	0xfff9,	0xfffc,	0x0000,	0x0004,	0x0008,	0x000c,	0x000e,
		0x0010,	0x0011,	0x0011,	0x0010,	0x000d,	0x000a,	0x0005,	0x0000,
		0xfffb,	0xfff6,	0xfff1,	0xffed,	0xffeb,	0xffe9,	0xffea,	0xffec,
		0xffef,	0xfff4,	0xfffa,	0x0000,	0x0007,	0x000d,	0x0013,	0x0018,
		0x001b,	0x001d,	0x001c,	0x001a,	0x0016,	0x0010,	0x0008,	0x0000,
		0xfff7,	0xffef,	0xffe8,	0xffe2,	0xffde,	0xffdc,	0xffdc,	0xffdf,
		0xffe5,	0xffec,	0xfff6,	0x0000,	0x000b,	0x0015,	0x001e,	0x0026,
		0x002b,	0x002d,	0x002d,	0x0029,	0x0022,	0x0018,	0x000d,	0x0000,
		0xfff3,	0xffe6,	0xffda,	0xffd1,	0xffcb,	0xffc8,	0xffc9,	0xffcd,
		0xffd6,	0xffe2,	0xfff0,	0x0000,	0x0011,	0x0020,	0x002f,	0x003a,
		0x0042,	0x0046,	0x0045,	0x003f,	0x0034,	0x0025,	0x0014,	0x0000,
		0xffec,	0xffd8,	0xffc6,	0xffb8,	0xffae,	0xffaa,	0xffab,	0xffb2,
		0xffc0,	0xffd2,	0xffe8,	0x0000,	0x0019,	0x0032,	0x0048,	0x005a,
		0x0066,	0x006b,	0x006a,	0x0061,	0x0050,	0x003a,	0x001f,	0x0000,
		0xffe0,	0xffc1,	0xffa6,	0xff8f,	0xff80,	0xff79,	0xff7b,	0xff86,
		0xff9a,	0xffb7,	0xffd9,	0x0000,	0x0028,	0x0050,	0x0073,	0x0090,
		0x00a5,	0x00ae,	0x00ac,	0x009e,	0x0084,	0x005f,	0x0033,	0x0000,
		0xffcb,	0xff97,	0xff67,	0xff40,	0xff24,	0xff17,	0xff18,	0xff2b,
		0xff4d,	0xff7e,	0xffba,	0x0000,	0x004a,	0x0093,	0x00d7,	0x0110,
		0x013a,	0x0151,	0x0151,	0x013a,	0x010a,	0x00c4,	0x006a,	0x0000,
		0xff8d,	0xff17,	0xfea6,	0xfe43,	0xfdf4,	0xfdc3,	0xfdb5,	0xfdd0,
		0xfe18,	0xfe8e,	0xff32,	0x0000,	0x00f4,	0x0208,	0x0331,	0x0467,
		0x059d,	0x06c8,	0x07dd,	0x08d1,	0x099a,	0x0a2f,	0x0a8b,	0x0aab,
		0x0a8b,	0x0a2f,	0x099a,	0x08d1,	0x07dd,	0x06c8,	0x059d,	0x0467,
		0x0331,	0x0208,	0x00f4,	0x0000,	0xff32,	0xfe8e,	0xfe18,	0xfdd0,
		0xfdb5,	0xfdc3,	0xfdf4,	0xfe43,	0xfea6,	0xff17,	0xff8d,	0x0000,
		0x006a,	0x00c4,	0x010a,	0x013a,	0x0151,	0x0151,	0x013a,	0x0110,
		0x00d7,	0x0093,	0x004a,	0x0000,	0xffba,	0xff7e,	0xff4d,	0xff2b,
		0xff18,	0xff17,	0xff24,	0xff40,	0xff67,	0xff97,	0xffcb,	0x0000,
		0x0033,	0x005f,	0x0084,	0x009e,	0x00ac,	0x00ae,	0x00a5,	0x0090,
		0x0073,	0x0050,	0x0028,	0x0000,	0xffd9,	0xffb7,	0xff9a,	0xff86,
		0xff7b,	0xff79,	0xff80,	0xff8f,	0xffa6,	0xffc1,	0xffe0,	0x0000,
		0x001f,	0x003a,	0x0050,	0x0061,	0x006a,	0x006b,	0x0066,	0x005a,
		0x0048,	0x0032,	0x0019,	0x0000,	0xffe8,	0xffd2,	0xffc0,	0xffb2,
		0xffab,	0xffaa,	0xffae,	0xffb8,	0xffc6,	0xffd8,	0xffec,	0x0000,
		0x0014,	0x0025,	0x0034,	0x003f,	0x0045,	0x0046,	0x0042,	0x003a,
		0x002f,	0x0020,	0x0011,	0x0000,	0xfff0,	0xffe2,	0xffd6,	0xffcd,
		0xffc9,	0xffc8,	0xffcb,	0xffd1,	0xffda,	0xffe6,	0xfff3,	0x0000,
		0x000d,	0x0018,	0x0022,	0x0029,	0x002d,	0x002d,	0x002b,	0x0026,
		0x001e,	0x0015,	0x000b,	0x0000,	0xfff6,	0xffec,	0xffe5,	0xffdf,
		0xffdc,	0xffdc,	0xffde,	0xffe2,	0xffe8,	0xffef,	0xfff7,	0x0000,
		0x0008,	0x0010,	0x0016,	0x001a,	0x001c,	0x001d,	0x001b,	0x0018,
		0x0013,	0x000d,	0x0007,	0x0000,	0xfffa,	0xfff4,	0xffef,	0xffec,
		0xffea,	0xffe9,	0xffeb,	0xffed,	0xfff1,	0xfff6,	0xfffb,	0x0000,
		0x0005,	0x000a,	0x000d,	0x0010,	0x0011,	0x0011,	0x0010,	0x000e,
		0x000c,	0x0008,	0x0004,	0x0000,	0xfffc,	0xfff9,	0xfff6,	0xfff4,
		0xfff3,	0xfff3,	0xfff3,	0xfff5,	0xfff7,	0xfffa,	0xfffd,	0x0000,
		0x0003,	0x0005,	0x0008,	0x0009,	0x000a,	0x000a,	0x0009,	0x0008,
		0x0007,	0x0005,	0x0002,	0x0000,	0xfffe,	0xfffc,	0xfffa,	0xfff9,
		0xfff9,	0xfff9,	0xfff9,	0xfffa,	0xfffb,	0xfffd,	0xfffe,	0x0000,
		0x0002,	0x0003,	0x0004,	0x0005,	0x0005,	0x0006,	0x0005,	0x0005,
		0x0004,	0x0003,	0x0001,	0x0000,	0xffff,	0xfffe,	0xfffd,	0xfffc,
		0xfffc,	0xfffc,	0xfffc,	0xfffc,	0xfffd,	0xfffe,	0xffff,	0x0000,
		0x0001,	0x0002,	0x0003,	0x0003,	0x0003,	0x0004,	0x0003,	0x0003,
		0x0002,	0x0002,	0x0001,	0x0000,	0xffff,	0xfffe,	0xfffe, 0x0000
};

void leftShiftby16(int *input, long *output, unsigned short dataLength)
{
    unsigned short index;

    for(index = 0; index< dataLength; index++)
    {
        output[index] = ((long)input[index] << 16);
    }
}

void rightShiftby16(long *input, int *output, unsigned short dataLength)
{
    unsigned short index;

    for(index = 0; index< dataLength; index++)
    {
        output[index] = (int)(input[index] >> 16);
    }
}

void copyBuf16(unsigned short *input, unsigned short *output, unsigned short dataLength)
{
    unsigned short index;

    for(index = 0; index < dataLength; index++)
    {
        output[index] = input[index];
    }
}

interrupt void dmaIsr(void)
{
    unsigned short ifrValue;

    /* Clear the DMA interrupt */
    ifrValue = DMA.getInterruptStatus();    
    if((ifrValue >> DMA_CHAN_ReadR) & 0x01)
    {
    	copyBuf16(AudioC.audioInLeft[AudioC.activeInBuf], fftBuf1, I2S_DMA_BUF_LEN);
    	copyBuf16(AudioC.audioInRight[AudioC.activeInBuf], fftBuf2, I2S_DMA_BUF_LEN);
    	readyForFFT = 1;
    }
    else if((ifrValue >> DMA_CHAN_WriteR) & 0x01)
    {
    	if(fftbufAvailable)
    	{
    	    writeBufIndex = (AudioC.activeOutBuf == FALSE)? TRUE: FALSE;	
	    copyBuf16(fftBuf1, AudioC.audioOutLeft[writeBufIndex], I2S_DMA_BUF_LEN);
	    copyBuf16(fftBuf2, AudioC.audioOutRight[writeBufIndex], I2S_DMA_BUF_LEN);
	    fftbufAvailable = 0;
	}
    }    
    
    AudioC.isrDma();
    
    if(readyForFFT)
    {
    	readyForFFT = 0;
        /* Compute FFT for left and right channels */
        FFTransform.FFT((int *)fftBuf1, I2S_DMA_BUF_LEN, ENABLE_SCALE, FFT_REAL, FFTQ15);
    	FFTransform.FFT((int *)fftBuf2, I2S_DMA_BUF_LEN, ENABLE_SCALE, FFT_REAL, FFTQ15);
    
#if 0
    	/* Convert data to 32bit complex value by shifting left 16 bits for left and right channels */
    	leftShiftby16((int *)fftBuf1, dmaBuffReadL32, I2S_DMA_BUF_LEN);
    	leftShiftby16((int *)fftBuf2, dmaBuffReadR32, I2S_DMA_BUF_LEN);
    
    	/* Pass the left and right channels data through filter */
    	FFTransform.filter(dmaBuffReadL32, coeff32, dmaBuffReadL32, I2S_DMA_BUF_LEN);
    	FFTransform.filter(dmaBuffReadR32, coeff32, dmaBuffReadR32, I2S_DMA_BUF_LEN);
    
    	/* Convert back data to 16bit real value by shifting right 16 bits for left and right channels */
    	rightShiftby16(dmaBuffReadL32, (int *)fftBuf1, I2S_DMA_BUF_LEN);
    	rightShiftby16(dmaBuffReadR32, (int *)fftBuf2, I2S_DMA_BUF_LEN);
#endif			
    	/* Compute IFFT for left and right channels */
    	FFTransform.IFFT((int *)fftBuf1, I2S_DMA_BUF_LEN, DISABLE_SCALE, FFT_REAL, FFTQ15);
    	FFTransform.IFFT((int *)fftBuf2, I2S_DMA_BUF_LEN, DISABLE_SCALE, FFT_REAL, FFTQ15);		
    	
    	fftbufAvailable = 1;			
    }

}

void setup() {
  int 	status;

    readyForFFT     = 0;	
    fftbufAvailable = 1;
    
	Serial.print("\n FFT TEST!\n");

        leftShiftby16(coeffs, coeff32, I2S_DMA_BUF_LEN);
        cbrev32(coeff32, coeff32, I2S_DMA_BUF_LEN);
	FFTransform.FFT(coeff32, I2S_DMA_BUF_LEN, DISABLE_SCALE, FFT_COMPLEX, FFTQ31);	


        status = AudioC.Audio(TRUE);
        if(status != 0)
        {
            Serial.print("\n Audio Init failed!\n");
        }
        else
        {
            Serial.print("\n Audio Init Done!\n");
        }

        AudioC.attachIntr((INTERRUPT_IsrPtr)dmaIsr);

       Serial.print("\n Interrupt is enabled !\n");

       AudioC.read();

       Serial.print("\n Audio Read!\n");

        AudioC.write();

       Serial.print("\n Audio Write!\n");
}

void loop() {

}
